<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Типовые ошибки</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
      .codeblock
      {
        background: #e0e0e0;
        border: solid 1px black;
        padding: 5px;
        font-family: monospace;
      }
      .codein
      {
        font-family: monospace;
      }
    td.numbers {text-align: right;}
    td.names {text-align: left;}
    td {text-align: center;}
    tr.odd {background-color: #e0e0e0;}
    </style>
  </head>
  <body>
    <h2>Типовые ошибки</h2>
    <h3>Получайте параметр функции по ссылке на константу, если вам не нужна его копия, и его копирование может быть дорогим.</h3>
    <h3>Получайте параметр функции по значению, если вам обязательно понадобится его копия. Не надо делать копию внутри функции.</h3>
    <p>В чем разница между этими двумя функциями?</p>
    <div class="codeblock">
    void f1(std::string s)<br/>
    {<br/>
       // меняем s<br/>
    }<br/>
    <br/>
    void f2(std::string const&amp; s)<br/>
    {<br/>
       std::string temp = s;<br/>
       // меняем temp<br/>
    }
    </div>
    Первая делает копию только если ей передали lvalue. Вторая делает копию всегда.
    <h3>Не забывайте когда нужно помечать конструктор как explicit, и не отмечайте, когда не нужно.</h3>
    <p>Конструктор имеющий один аргумент будет использоваться при неявном приведении типов. Так же в неявном приведении типов может
    использоваться конструктор имеющий два аргумента с дефолтным вторым аргументом или конструктор с тремя аргументами имеющий дефолтные
    второй и третий аргументы, etc.</p>
    <p>Если неявное приведение типов нежелательно отметьте такой конструктор как explicit. Не надо отмечать конструктор как explicit, если
    он не может сработать при неявном приведении типов (например, конструктор имеет ноль аргументов).</p>
    <h3>Внимательно смотрите за тем какие члены класса у вас public, а какие private.</h3>
    <p>Существуют две причины почему некоторый член класса не должен быть public</p>
    <ul>
      <li>Если используя его можно испортить инвариант класса.</li>
      <li>Если мы рассматриваем его как деталь реализации и не хотим, чтобы пользователи затачивались на него. Если пользователи не
      смогут им воспользоваться, значит его можно будет менять как угодно не беспокоясь, что мы сломаем чужой код.</li>
    </ul>
    <p>Распространённой практикой является делать данные класса private.</p>
    <h3>Старайтесь делать ваши хедера самодостаточными, так чтобы они не требовали, чтобы было что-то проиклужено перед ними.</h3>
    <p>Это упрощает жизнь.</p>
    <h3>Старайтесь инклудить хедер соответствующий cpp'шнику первым в этом cpp'шнике.</h3>
    <p>Это даст вам возможность убедиться, что ваш хедер самодостаточный и для своей работы не требует, чтобы было проиклужено что-то ещё.
    Конечно, если вы используете precompiled-хедера, первым должен быть проиклужен precompiled-хедер, значит ваш хедер будет идти вторым.</p>
    <h3>Минимизируйте зависимости между хедерами.</h3>
    <p>Не надо инклудить то, что можно не инклудить. Это очень сильно влияет на время перекомпиляции (изменили чуть-чуть &mdash; пересобрать
    пришлось много). В некоторых случаях бывает достаточно объявить неполный тип, а не инклудить хедер с классом целиком со всеми зависимостями.
    Например:</p>
    <div class="codeblock">
    // myfunc.h<br/><br/>
    #include "mytype.h"<br/><br/>
    void myfunc(mytype a);
    </div>
    <p>Данному хедеру совсем необязательно инклудить <span class="codein">mytype.h</span>. Достаточно объявить неполный тип:</p>
    <div class="codeblock">
    // myfunc.h<br/><br/>
    struct mytype;<br/><br/>
    void myfunc(mytype a);
    </div>
    <h3>Не делайте циклы на хедерах.</h3>
    <h3>Не забывайте ставить include-guard'ы в хедерах.</h3>
    <h3>Не выносите в хедер, то что может жить в cpp'шнике.</h3>
    <h3>Используйте size_t, а не int как тип для индексов элементов массива/вектора/любого контейнера.</h3>
    <p>Функция size() возвращает size_t, который на 64-битных системах 64-битный. int на 64-битных системах 32-битный. Это означает, что такой
    цикл никогда не завершается, если <span class="codein">v</span> содержит больше 2^31 элементов.</p>
    <div class="codeblock">
    std::vector<std::string> v;<br/>
    for (int i = 0; i != v.size(); ++i);
    </div>
    <p>Плюс использование size_t возволит вам избавиться от кучи signed/unsigned mismatch ворнингов.</p>
    <h3>Если магическая константа встречается больше одного раза, возможно, стоит дать ей имя.</h3>
    <h3>Предпочитайте список инициализации, присваиванию в теле конструктора.</h3>
    <h3>Не передавайте временный объект в функцию получающую аргумент по ссылке на не константу.</h3>
    <p>MSVC пропускает это как расширение. На gcc такой код не компилируется. Чтобы отловить это в MSVC включите 4 уровень warning'ов.</p>
    <h3>Предпочитайте mutable, const_cast'ам.</h3>
    <p>Компилятор может разместить константную глобальную переменную в read-only области памяти.</p>
    <h3>Пишите программы так, чтобы в них не было незакрытых файловых дескрипторов/сокетов/любых системных хендлов и неосвобожденных блоков
    памяти.</h3>
    <p>Если ваша программа отрабатывает и выходит, может прокатить и без этого. Но если ваша программа должна работать продолжительное время
    все ресурсы должны возвращаться системе иначе в какой-то момент они закончатся.</p>
    <p>Если вы пишете библиотеку вы не можете угадать в программе какого типа её будут использовать. Поэтому ваша библиотека должна вести
    себя хорошо.</p>
    <p>Хорошо писать код который потом можно будет переиспользовать. Если в коде ликает память, могут возникнуть проблемы с переиспользованием
    этого кода.</p>
    <h3>Если вы написали new вам стоит остановиться и подумать.</h3>
    <ul>
      <li>Не забыл ли я поставить delete?</li>
      <li>А не может ли произойти return/break/исключение так, что управление до delete никогда не дойдет?</li>
      <li>Не перепутал ли я delete и delete[]?</li>
    </ul>
    <p>Поэтому проще использовать RAII'шные классы. Например, использовать vector вместо new[]. Обычный new можно обернуть в unique_ptr или shared_ptr.</p>
    <p>Тоже самое относится если вы открываете файл/сокет/любой системный хендл не используя RAII.</p>
    <h3>Не выносите переменные/типы во внешний scope без необходимости.</h3>
    <p>Если переменная может быть внутри класса &mdash; пусть будет внутри класса. Если переменная может быть внутри тела цикла, а не снаружи
    &mdash; пусть будет внутри.</p>
    <p>
      <a href="http://validator.w3.org/check?uri=referer">
        <img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Strict" height="31" width="88" />
      </a>
    </p>
  </body>
</html>

